<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>뇌 모델</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000000; color: #fff; font-family: sans-serif; }
        canvas { display: block; }
        #loader {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5em;
        }
    </style>
</head>
<body>
    <div id="loader">데이터 로딩 중...</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    let scene, camera, renderer, controls, brainGroup, composer;
    let brainParticles;
    const mouse = new THREE.Vector2(-100, -100);
    const raycaster = new THREE.Raycaster();
    raycaster.params.Points.threshold = 1.5; 

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.FogExp2(0x000000, 0.007);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 280);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 80; 
        controls.maxDistance = 350; 
        controls.enablePan = false;
        
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0;
        bloomPass.strength = 1.2;
        bloomPass.radius = 0.5;

        composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        loadBrainData();
        
        window.addEventListener('resize', onWindowResize);
        document.addEventListener('mousemove', onMouseMove);
    }

    async function loadBrainData() {
        try {
            const response = await fetch('brain.json');
            const data = await response.json();
            createDigitalBrain(data);
            document.getElementById('loader').style.display = 'none';
        } catch (error) {
            console.error("뇌 데이터를 로드할 수 없습니다:", error);
            document.getElementById('loader').innerText = "오류: brain.json 파일을 찾을 수 없습니다. Python 스크립트를 먼저 실행했는지 확인해주세요.";
        }
    }

    function createDigitalBrain(data) {
        brainGroup = new THREE.Group();
        scene.add(brainGroup);
        
        const vertices = new Float32Array(data.vertices.flat());
        const numVertices = vertices.length / 3;

        const particleGeometry = new THREE.BufferGeometry();
        particleGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        
        const colors = new Float32Array(numVertices * 3);
        const color = new THREE.Color();
        color.setHSL(0.6, 0.9, 0.6);

        for (let i = 0; i < numVertices; i++) {
            colors.set([color.r, color.g, color.b], i * 3);
        }
        
        particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        particleGeometry.setAttribute('originalColor', new THREE.BufferAttribute(colors.slice(), 3));

        const particleMaterial = new THREE.PointsMaterial({
            size: 0.8,
            sizeAttenuation: true,
            map: createCircleTexture(),
            vertexColors: true,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        brainParticles = new THREE.Points(particleGeometry, particleMaterial);
        brainGroup.add(brainParticles);

        const lineGeometry = new THREE.BufferGeometry();
        lineGeometry.setAttribute('position', particleGeometry.getAttribute('position')); 
        lineGeometry.setIndex(data.faces.flat());

        const lineMaterial = new THREE.LineBasicMaterial({
            color: 0x99bbff, 
            transparent: true,
            opacity: 0.25,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const wireframe = new THREE.WireframeGeometry(lineGeometry);
        const brainLines = new THREE.LineSegments(wireframe, lineMaterial);
        brainGroup.add(brainLines);

        brainGroup.rotation.x = -Math.PI / 2;
        brainGroup.rotation.z = Math.PI / 2;
    }
    
    function createCircleTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 128;
        canvas.height = 128;
        const context = canvas.getContext('2d');
        const gradient = context.createRadialGradient(64, 64, 0, 64, 64, 64);
        gradient.addColorStop(0, 'rgba(255,255,255,1)');
        gradient.addColorStop(0.2, 'rgba(200,200,255,0.8)');
        gradient.addColorStop(0.8, 'rgba(150,150,255,0.1)');
        gradient.addColorStop(1, 'rgba(0,0,0,0)');
        context.fillStyle = gradient;
        context.fillRect(0, 0, 128, 128);
        return new THREE.CanvasTexture(canvas);
    }

    function animate() {
        requestAnimationFrame(animate);

        if (brainGroup) {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(brainParticles);
            
            const particleColors = brainParticles.geometry.attributes.color;
            const originalColors = brainParticles.geometry.attributes.originalColor;
            
            particleColors.copy(originalColors);

            if (intersects.length > 0) {
                const intersectIndex = intersects[0].index;
                const intersectionPoints = brainParticles.geometry.attributes.position;
                const p = new THREE.Vector3().fromBufferAttribute(intersectionPoints, intersectIndex);
                
                const interactionRadius = 25.0;
                const highlightColor = new THREE.Color(0xffffff); 

                for (let i = 0; i < particleColors.count; i++) {
                    const tempP = new THREE.Vector3().fromBufferAttribute(intersectionPoints, i);
                    const distance = p.distanceTo(tempP);

                    if (distance < interactionRadius) {
                        const intensity = Math.pow(1 - distance / interactionRadius, 2.0);
                        const originalColor = new THREE.Color().fromBufferAttribute(originalColors, i);
                        
                        originalColor.lerp(highlightColor, intensity);
                        particleColors.setXYZ(i, originalColor.r, originalColor.g, originalColor.b);
                    }
                }
            }
            particleColors.needsUpdate = true;
        }

        controls.update();
        composer.render();
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight); 
    }

    function onMouseMove(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    }

    init();
    animate();
</script>
</body>
</html>